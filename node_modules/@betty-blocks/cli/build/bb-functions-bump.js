"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const commander_1 = __importDefault(require("commander"));
const prompts_1 = __importDefault(require("prompts"));
const chalk_1 = __importDefault(require("chalk"));
const functionDefinitions_1 = require("./functions/functionDefinitions");
commander_1.default.name('bb functions bump');
const check = chalk_1.default.green(`✔`);
const cross = chalk_1.default.red(`✖`);
const workingDir = process.cwd();
const baseFunctionsPath = path_1.default.join(workingDir, 'functions');
const collectBumpInput = () => __awaiter(void 0, void 0, void 0, function* () {
    const functionDir = (functionPath) => path_1.default.basename(path_1.default.dirname(path_1.default.dirname(functionPath)));
    const versionedFunctions = functionDefinitions_1.functionDefinitions(baseFunctionsPath);
    const functions = versionedFunctions.reduce((acc, { schema: { label }, path: functionPath }) => {
        const name = functionDir(functionPath);
        acc[name] = label;
        return acc;
    }, {});
    const dirName = (yield prompts_1.default({
        type: 'select',
        name: 'functionName',
        message: 'Which function do you want to bump?',
        choices: Object.keys(functions).map((name) => ({
            title: functions[name],
            value: name,
        })),
        initial: 0,
    })).functionName;
    const [[major, minor]] = versionedFunctions
        .filter(({ path: functionPath }) => functionDir(functionPath) === dirName)
        .sort(({ version: a }, { version: b }) => parseFloat(a) - parseFloat(b))
        .slice(-1)
        .map(({ version }) => version.split('.').map(Number));
    const majorVersion = `${major + 1}.0`;
    const minorVersion = `${major}.${minor + 1}`;
    const { bumpMajor } = (yield prompts_1.default({
        type: 'toggle',
        name: 'bumpMajor',
        message: `To which version do you want to bump your function?`,
        initial: false,
        active: majorVersion,
        inactive: minorVersion,
    }));
    return {
        newVersion: bumpMajor ? majorVersion : minorVersion,
        currentVersion: `${major}.${minor}`,
        dirName,
    };
});
// eslint-disable-next-line no-void
void (() => __awaiter(void 0, void 0, void 0, function* () {
    const { dirName, newVersion, currentVersion } = yield collectBumpInput();
    const sourceDir = path_1.default.join(workingDir, 'functions', dirName, currentVersion);
    const targetDir = path_1.default.join(workingDir, 'functions', dirName, newVersion);
    try {
        fs_extra_1.default.copySync(sourceDir, targetDir);
        console.log(`${check} Version bumped to ${path_1.default.join(dirName, newVersion)}`);
    }
    catch (_a) {
        console.log(`${cross} Failed to bump version to  ${path_1.default.join(dirName, newVersion)}`);
    }
}))();
//# sourceMappingURL=bb-functions-bump.js.map