"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = __importDefault(require("chalk"));
function fromStructure(object, structure) {
    if (typeof structure === 'string') {
        const value = object[structure];
        if (typeof value === 'string' || typeof value === 'undefined') {
            return value;
        }
    }
    const [[k, v]] = Object.entries(structure);
    return fromStructure(object[k], v);
}
exports.findDuplicates = (list, type, structure) => {
    list.reduce((acc, item) => {
        let value;
        try {
            value = fromStructure(item, structure);
        }
        catch (_a) {
            // all is well in the world
        }
        if (typeof value === 'string') {
            const valueLower = value.toLowerCase();
            if (acc.has(valueLower)) {
                throw new Error(chalk_1.default.red(`\nThe name "${valueLower}" is used for multiple ${type}s\n`));
            }
            acc.add(valueLower);
        }
        return acc;
    }, new Set());
};
const checkComponentReferenceNames = (names, prefabName) => (prefabReference) => {
    if (prefabReference.type === undefined ||
        prefabReference.type === 'COMPONENT') {
        const { name, descendants } = prefabReference;
        if (!names.has(name)) {
            throw new Error(chalk_1.default.red(`\nPrefab: ${prefabName} references to non-existing component "${name}"\n`));
        }
        descendants.forEach(checkComponentReferenceNames(names, prefabName));
    }
    else if (prefabReference.type === 'WRAPPER') {
        const { descendants } = prefabReference;
        descendants.forEach(checkComponentReferenceNames(names, prefabName));
    }
};
exports.checkNameReferences = (prefabs, components) => {
    const componentNames = new Set(components.map(({ name }) => name));
    prefabs.forEach(({ name, structure }) => {
        structure.forEach(checkComponentReferenceNames(componentNames, name));
    });
};
function checkOptionCategoryReferences(prefabs) {
    function innerFn(structure, name) {
        structure.forEach((prefabReference) => {
            if (prefabReference.type === undefined ||
                prefabReference.type === 'COMPONENT' ||
                prefabReference.type === 'WRAPPER') {
                if (prefabReference === null || prefabReference === void 0 ? void 0 : prefabReference.optionCategories) {
                    prefabReference.optionCategories.forEach((category) => {
                        category.members.forEach((member) => {
                            if (!prefabReference.options.some((option) => member === option.key)) {
                                throw new Error(chalk_1.default.red(`\nOption category member: "${member}" references to non-existing option\n\nat prefab: ${name}`));
                            }
                        });
                    });
                }
                innerFn(prefabReference.descendants, name);
            }
        });
    }
    prefabs.forEach((prefab) => {
        innerFn(prefab.structure, prefab.name);
    });
}
exports.checkOptionCategoryReferences = checkOptionCategoryReferences;
//# sourceMappingURL=validation.js.map