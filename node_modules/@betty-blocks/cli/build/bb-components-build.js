"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-argument,@typescript-eslint/no-unsafe-return,@typescript-eslint/restrict-template-expressions */
const chalk_1 = __importDefault(require("chalk"));
const path_1 = __importDefault(require("path"));
const commander_1 = __importDefault(require("commander"));
const typescript_1 = __importDefault(require("typescript"));
const fs_extra_1 = require("fs-extra");
const compatibility_1 = __importDefault(require("./components/compatibility"));
const transformers_1 = require("./components/transformers");
const compatibility_2 = __importDefault(require("./interactions/compatibility"));
const diagnostics_1 = __importDefault(require("./interactions/diagnostics"));
const arguments_1 = require("./utils/arguments");
const checkUpdateAvailable_1 = require("./utils/checkUpdateAvailable");
const checkPackageVersion_1 = require("./utils/checkPackageVersion");
const hash_1 = __importDefault(require("./utils/hash"));
const readFilesByType_1 = __importDefault(require("./utils/readFilesByType"));
const transpile_1 = __importDefault(require("./utils/transpile"));
const validation_1 = require("./utils/validation");
const component_1 = __importDefault(require("./validations/component"));
const styles_1 = __importDefault(require("./validations/styles"));
const interaction_1 = __importDefault(require("./validations/interaction"));
const prefab_1 = __importDefault(require("./validations/prefab"));
const components_build_1 = require("./components-build");
const buildInteractions_1 = require("./components-build/v2/buildInteractions");
const { mkdir, readFile } = fs_extra_1.promises;
/* process arguments */
commander_1.default
    .usage('[path]')
    .name('bb components build')
    .option('-t, --transpile', 'enable new transpilation')
    .option('--runtime-version [version]', 'the runtime option to build for', 'v1')
    .parse(process.argv);
const { args } = commander_1.default;
const options = commander_1.default.opts();
const rootDir = arguments_1.parseDir(args);
const distDir = `${rootDir}/dist`;
const enableNewTranspile = !!options.transpile;
/* execute command */
const readComponents = () => __awaiter(void 0, void 0, void 0, function* () {
    const srcDir = `${rootDir}/src/components`;
    const exists = yield fs_extra_1.pathExists(srcDir);
    if (!exists) {
        throw new Error(chalk_1.default.red('\nComponents folder not found\n'));
    }
    const componentFiles = yield readFilesByType_1.default(srcDir);
    const components = componentFiles.map((file) => __awaiter(void 0, void 0, void 0, function* () {
        try {
            const code = yield readFile(`${srcDir}/${file}`, 'utf-8');
            const compatibility = compatibility_1.default(code);
            // eslint-disable-next-line @typescript-eslint/no-implied-eval
            const transpiledFunction = Function(`return ${transpile_1.default(code, ['jsx', 'styles'])}`)();
            if (!transpiledFunction) {
                throw new Error("Component doesn't return anything");
            }
            if (enableNewTranspile) {
                transpiledFunction.transpiledJsx = transformers_1.doTranspile(transpiledFunction.jsx);
                transpiledFunction.transpiledStyles = transformers_1.doTranspile(transpiledFunction.styles);
            }
            if (transpiledFunction.dependencies) {
                const usedPackages = transpiledFunction.dependencies.map((usedDependency) => usedDependency.package);
                const dependencyPromises = usedPackages.map((usedPackage) => __awaiter(void 0, void 0, void 0, function* () {
                    yield checkPackageVersion_1.checkPackageVersion(usedPackage.replace(/^npm:/g, ''));
                }));
                yield Promise.all(dependencyPromises);
            }
            return Object.assign(Object.assign({}, compatibility), transpiledFunction);
        }
        catch (error) {
            error.file = file;
            throw error;
        }
    }));
    return Promise.all(components);
});
const readtsPrefabs = () => __awaiter(void 0, void 0, void 0, function* () {
    const absoluteRootDir = path_1.default.resolve(process.cwd(), rootDir);
    const srcDir = `${absoluteRootDir}/src/prefabs`;
    const exists = yield fs_extra_1.pathExists(srcDir);
    if (!exists) {
        throw new Error(chalk_1.default.red('\nPrefabs folder not found\n'));
    }
    const prefabTsFiles = yield readFilesByType_1.default(srcDir, 'ts');
    const prefabTsxFiles = yield readFilesByType_1.default(srcDir, 'tsx');
    const prefabFiles = [...prefabTsFiles, ...prefabTsxFiles];
    const prefabProgram = typescript_1.default.createProgram(prefabFiles.map((file) => `${srcDir}/${file}`), {
        jsx: 2,
        outDir: '.prefabs',
        module: 1,
        esModuleInterop: true,
        allowSyntheticDefaultImports: false,
        target: 99,
        listEmittedFiles: true,
    });
    const diagnostics = [...typescript_1.default.getPreEmitDiagnostics(prefabProgram)];
    if (diagnostics.length > 0) {
        components_build_1.reportDiagnostics(diagnostics);
        process.exit(1);
    }
    const results = prefabProgram.emit();
    if (results.diagnostics.length > 0) {
        components_build_1.reportDiagnostics([...results.diagnostics]);
        process.exit(1);
    }
    const globalDiagnostics = [...prefabProgram.getGlobalDiagnostics()];
    if (globalDiagnostics.length > 0) {
        components_build_1.reportDiagnostics(globalDiagnostics);
        process.exit(1);
    }
    const declarationDiagnostics = [...prefabProgram.getDeclarationDiagnostics()];
    if (declarationDiagnostics.length > 0) {
        components_build_1.reportDiagnostics(declarationDiagnostics);
        process.exit(1);
    }
    const configDiagnostics = [
        ...prefabProgram.getConfigFileParsingDiagnostics(),
    ];
    if (configDiagnostics.length > 0) {
        components_build_1.reportDiagnostics(configDiagnostics);
        process.exit(1);
    }
    const prefabs = (results.emittedFiles || [])
        .filter((filename) => /\.(\w+\/){2}\w+\.js/.test(filename))
        .map((filename) => {
        return new Promise((resolve) => {
            Promise.resolve().then(() => __importStar(require(`${absoluteRootDir}/${filename}`))).then((prefab) => {
                // JSON schema validation
                resolve(prefab.default);
            })
                .catch((error) => {
                throw new Error(`in ${filename}: ${error}`);
            });
        });
    });
    return Promise.all(prefabs);
});
const readPrefabs = () => __awaiter(void 0, void 0, void 0, function* () {
    const srcDir = `${rootDir}/src/prefabs`;
    const exists = yield fs_extra_1.pathExists(srcDir);
    if (!exists) {
        throw new Error(chalk_1.default.red('\nPrefabs folder not found\n'));
    }
    const prefabFiles = yield readFilesByType_1.default(srcDir);
    const prefabs = prefabFiles.map((file) => __awaiter(void 0, void 0, void 0, function* () {
        try {
            const code = yield readFile(`${srcDir}/${file}`, 'utf-8');
            // eslint-disable-next-line @typescript-eslint/no-implied-eval,@typescript-eslint/no-unsafe-assignment
            const transpiledFunction = Function(`return ${transpile_1.default(code, ['beforeCreate'])}`)();
            if (!transpiledFunction) {
                throw new Error("Prefab doesn't return anything");
            }
            return transpiledFunction;
        }
        catch (error) {
            error.file = file;
            throw error;
        }
    }));
    return Promise.all(prefabs);
});
const readPartialPrefabs = () => __awaiter(void 0, void 0, void 0, function* () {
    const srcDir = `${rootDir}/src/prefabs/partials`;
    const exists = yield fs_extra_1.pathExists(srcDir);
    if (!exists) {
        yield mkdir(srcDir, { recursive: true });
    }
    const partialPrefabFiles = yield readFilesByType_1.default(srcDir);
    const partialPrefabs = partialPrefabFiles.map((file) => __awaiter(void 0, void 0, void 0, function* () {
        try {
            const code = yield readFile(`${srcDir}/${file}`, 'utf-8');
            // eslint-disable-next-line @typescript-eslint/no-implied-eval,@typescript-eslint/no-unsafe-assignment
            const transpiledFunction = Function(`return ${transpile_1.default(code, ['beforeCreate'])}`)();
            if (!transpiledFunction) {
                throw new Error("Prefab doesn't return anything");
            }
            return transpiledFunction;
        }
        catch (error) {
            error.file = file;
            throw error;
        }
    }));
    return Promise.all(partialPrefabs);
});
const readInteractions = () => __awaiter(void 0, void 0, void 0, function* () {
    const srcDir = `${rootDir}/src/interactions`;
    const exists = yield fs_extra_1.pathExists(srcDir);
    if (!exists) {
        return new Promise((resolve) => {
            resolve([]);
        });
    }
    const interactionFiles = yield readFilesByType_1.default(srcDir, 'ts');
    return Promise.all(interactionFiles.map((file) => __awaiter(void 0, void 0, void 0, function* () {
        try {
            const code = yield readFile(`${srcDir}/${file}`, 'utf-8');
            diagnostics_1.default(`${srcDir}/${file}`);
            return Object.assign({ function: code }, compatibility_2.default(`${srcDir}/${file}`));
        }
        catch (error) {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
            error.file = file;
            throw error;
        }
    })));
});
// eslint-disable-next-line no-void
void (() => __awaiter(void 0, void 0, void 0, function* () {
    yield checkUpdateAvailable_1.checkUpdateAvailableCLI();
    const { runtimeVersion = 'v1' } = options;
    try {
        const [styles, newPrefabs, oldPrefabs, components, interactions, partialprefabs,] = yield Promise.all([
            components_build_1.readStyles(rootDir),
            readtsPrefabs(),
            readPrefabs(),
            readComponents(),
            runtimeVersion === 'v2' ? Promise.resolve([]) : readInteractions(),
            readPartialPrefabs(),
        ]);
        const validStyleTypes = styles.map(({ type }) => type);
        const prefabs = oldPrefabs.concat(newPrefabs);
        const stylesGroupedByTypeAndName = styles.reduce((object, e) => {
            const { name, type } = e;
            const byType = object[type] || {};
            return Object.assign(Object.assign({}, object), { [type]: Object.assign(Object.assign({}, byType), { [name]: e }) });
        }, {});
        const componentNames = components.map(({ name }) => name);
        validation_1.checkNameReferences(prefabs, components);
        const componentStyleMap = components.reduce((acc, c) => {
            return c.styleType
                ? Object.assign(acc, { [c.name]: { styleType: c.styleType } })
                : acc;
        }, {});
        yield Promise.all([
            styles_1.default(styles, componentNames),
            component_1.default(components, validStyleTypes),
            prefab_1.default(prefabs, stylesGroupedByTypeAndName, componentStyleMap),
            prefab_1.default(partialprefabs, stylesGroupedByTypeAndName, componentStyleMap, 'partial'),
            interactions && interaction_1.default(interactions),
        ]);
        validation_1.checkOptionCategoryReferences(prefabs);
        const componentsWithHash = components.map((component) => {
            return Object.assign(Object.assign({}, component), { componentHash: hash_1.default(component) });
        });
        const buildPrefab = (prefab) => {
            const buildStructure = (structure) => {
                if (structure.type === 'PARTIAL') {
                    return structure;
                }
                if (structure.type === 'WRAPPER') {
                    const { descendants = [] } = structure, rest = __rest(structure, ["descendants"]);
                    const wrapperStructure = Object.assign(Object.assign({}, rest), { descendants: descendants.map(buildStructure) });
                    return wrapperStructure;
                }
                const { style, descendants } = structure, rest = __rest(structure, ["style", "descendants"]);
                const styleReference = components_build_1.buildReferenceStyle(style);
                const newStructure = Object.assign(Object.assign(Object.assign({}, rest), (styleReference ? { style: styleReference } : {})), { hash: hash_1.default(structure.options), descendants: descendants.map(buildStructure) });
                return newStructure;
            };
            return Object.assign(Object.assign({}, prefab), { structure: prefab.structure.map(buildStructure) });
        };
        const buildStyles = styles.map(components_build_1.buildStyle);
        const buildPrefabs = prefabs.map(buildPrefab);
        const buildPartialprefabs = partialprefabs.map(buildPrefab);
        yield mkdir(distDir, { recursive: true });
        const defaultPrefabs = buildPrefabs.filter((prefab) => prefab.type !== 'page');
        const outputPromises = [
            fs_extra_1.outputJson(`${distDir}/prefabs.json`, defaultPrefabs),
            fs_extra_1.outputJson(`${distDir}/templates.json`, componentsWithHash),
            interactions && fs_extra_1.outputJson(`${distDir}/interactions.json`, interactions),
        ];
        if (buildStyles.length > 0) {
            outputPromises.push(fs_extra_1.outputJson(`${distDir}/styles.json`, buildStyles));
        }
        const pagePrefabs = prefabs.filter((prefab) => prefab.type === 'page');
        if (pagePrefabs.length > 0) {
            outputPromises.push(fs_extra_1.outputJson(`${distDir}/pagePrefabs.json`, pagePrefabs));
        }
        const existingPath = yield fs_extra_1.pathExists(`${distDir}/pagePrefabs.json`);
        if (pagePrefabs.length === 0 && existingPath) {
            yield fs_extra_1.remove(`${distDir}/pagePrefabs.json`);
        }
        if (buildPartialprefabs.length > 0) {
            outputPromises.push(fs_extra_1.outputJson(`${distDir}/partials.json`, buildPartialprefabs));
        }
        const existingPartialPath = yield fs_extra_1.pathExists(`${distDir}/partials.json`);
        if (buildPartialprefabs.length === 0 && existingPartialPath) {
            yield fs_extra_1.remove(`${distDir}/partials.json`);
        }
        yield Promise.all(outputPromises);
        // v2
        if (runtimeVersion === 'v2') {
            yield buildInteractions_1.buildInteractions(rootDir);
        }
        console.info(chalk_1.default.green('Success, the component set has been built'));
    }
    catch (err) {
        // TODO: reduce scope of this try catch to narrow the type of error.
        // some errors will not contain these fields so it is unsafe to
        // destructure
        // eslint-disable-next-line prefer-destructuring
        const name = err.name;
        // eslint-disable-next-line prefer-destructuring
        const file = err.file;
        // eslint-disable-next-line prefer-destructuring
        const message = err.message;
        if (!name || !file || !message) {
            console.error(err);
            process.exit(1);
        }
        if (file) {
            console.error(chalk_1.default.red(`\n${name} in ${file}: ${message}\n`));
        }
        else {
            console.error(chalk_1.default.red(`\n${name}: ${message}\n`));
        }
        process.exit(1);
    }
}))();
//# sourceMappingURL=bb-components-build.js.map