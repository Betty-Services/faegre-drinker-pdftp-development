"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const adm_zip_1 = __importDefault(require("adm-zip"));
const camelCase_1 = __importDefault(require("lodash/camelCase"));
const startCase_1 = __importDefault(require("lodash/startCase"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const glob_1 = __importDefault(require("glob"));
const path_1 = __importDefault(require("path"));
const lodash_1 = require("lodash");
/* @doc functionDefinitionPath
  Expands the function dir with `function.json`.
*/
const functionDefinitionPath = (functionPath) => path_1.default.join(functionPath, 'function.json');
exports.functionDefinitionPath = functionDefinitionPath;
/* @doc functionImplementationPath
  Expands the function dir with `index.js`.
*/
const functionImplementationPath = (functionPath) => path_1.default.join(functionPath, 'index.js');
/* @doc isFunctionDefinition
  Checks the given functions dir for a file named function.json.
  Returns true if the file exists.
*/
const isFunctionDefinition = (functionPath) => fs_extra_1.default.pathExistsSync(functionDefinitionPath(functionPath));
exports.isFunctionDefinition = isFunctionDefinition;
/* @doc isFunctionVersion
  Checks the given functions dir to be a function version.
  Returns true if applies to versioning conventions.
*/
const isFunctionVersion = (functionPath, functionsDir) => !!path_1.default.basename(functionPath).match(/^\d+\.\d+$/) &&
    parseFloat(path_1.default.basename(functionPath)) >= 1.0 &&
    path_1.default.dirname(path_1.default.dirname(functionPath)) === functionsDir;
exports.isFunctionVersion = isFunctionVersion;
/* @doc isFunction
  Checks the given functions dir for a file named index.js.
  Returns true if the file exists.
*/
const isFunction = (functionPath) => fs_extra_1.default.pathExistsSync(functionImplementationPath(functionPath));
/* @doc functionDirs
  Returns a list of directories inside the given functionsDir that have a function.json and index.js.
*/
const functionDirs = (functionsDir, includeNonversioned = false) => glob_1.default
    .sync(path_1.default.join(functionsDir, '**', 'function.json').replace(/\\/g, '/'))
    .reduce((dirs, functionDefinition) => {
    const dir = path_1.default.dirname(functionDefinition).replace(/\//g, path_1.default.sep);
    if (isFunction(dir) &&
        (includeNonversioned || isFunctionVersion(dir, functionsDir))) {
        dirs.push(dir);
    }
    return dirs;
}, []);
exports.functionDirs = functionDirs;
/* @doc functionDefinition
  Reads the function.json from the given directory.
  Returns the parsed function.json as object.
*/
const functionDefinition = (functionPath, functionsDir) => {
    let name = '';
    let version = '';
    if (isFunctionVersion(functionPath, functionsDir)) {
        name = camelCase_1.default(path_1.default.basename(path_1.default.dirname(functionPath)));
        version = path_1.default.basename(functionPath);
    }
    else {
        name = camelCase_1.default(path_1.default.basename(functionPath));
    }
    const filePath = functionDefinitionPath(functionPath);
    const schema = fs_extra_1.default.readJSONSync(filePath);
    try {
        return {
            name,
            version,
            path: filePath,
            schema,
        };
    }
    catch (err) {
        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
        throw new Error(`could not load json from ${filePath}: ${err}`);
    }
};
exports.functionDefinition = functionDefinition;
/* @doc functionDefinitions
  Returns an object containing all function.json definitions
  inside the given functionsDir, indexed by function name.
*/
const functionDefinitions = (functionsDir, includeNonversioned = false) => {
    return functionDirs(functionsDir, includeNonversioned).map((functionDir) => functionDefinition(functionDir, functionsDir));
};
exports.functionDefinitions = functionDefinitions;
const stringifyDefinitions = (definitions) => {
    const updatedDefinitions = definitions.map(({ name, version, schema }) => (Object.assign(Object.assign({ name,
        version }, schema), { options: JSON.stringify(schema.options || []), paths: JSON.stringify(schema.paths || {}) })));
    return JSON.stringify(updatedDefinitions);
};
exports.stringifyDefinitions = stringifyDefinitions;
/* @doc newFunctionDefinition
  Creates a new folder for the given name and fills that folder with a function.json file
  and an index.js.
*/
const newFunctionDefinition = (functionsDir, functionName) => {
    const functionDefName = functionName.replace(/-./g, (x) => x.toUpperCase()[1]);
    const functionDir = path_1.default.join(functionsDir, functionName, '1.0');
    try {
        fs_extra_1.default.mkdirpSync(functionDir);
        fs_extra_1.default.writeJSONSync(functionDefinitionPath(functionDir), {
            description: 'Description',
            label: startCase_1.default(functionName),
            category: 'Misc',
            icon: {
                name: 'ActionsIcon',
                color: 'Orange',
            },
            options: [],
            yields: 'NONE',
        }, { spaces: 2 });
        fs_extra_1.default.writeFileSync(path_1.default.join(functionDir, 'index.js'), `const ${functionDefName} = async () => {\n\n}\n\nexport default ${functionDefName};`);
    }
    catch (err) {
        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
        throw new Error(`could not initialize new function ${functionDir}: ${err}`);
    }
};
exports.newFunctionDefinition = newFunctionDefinition;
const toVariableName = ({ name, version }) => `${camelCase_1.default(name)}_${version.replace('.', '_')}`;
/* @doc importFunctions
  Returns an array of strings, each item being an imported function:
  `import { default as functionName_1_0 } from './function-name/1.0';`;
*/
const importFunctions = (definitions, functionsPath) => definitions.map((definition) => `import { default as ${toVariableName(definition)} } from '${path_1.default
    .dirname(definition.path.replace(functionsPath, `./${path_1.default.basename(functionsPath)}`))
    .replace(/\\/g, '/')}';`);
/* @doc exportFunctions
  Returns a string in which functions will be exported in an object;
*/
const exportFunctions = (definitions) => {
    const exports = definitions.map((definition) => {
        const { name, version } = definition;
        return `  "${name} ${version}": ${toVariableName(definition)},`;
    });
    return ['const fn = {', ...exports, '};', '', 'export default fn;'];
};
/* @doc whitelistedFunctions
  Returns an array containing all functions based on the whitelist.
*/
const whitelistedFunctions = (definitions, whitelist) => whitelist.map((whitelisted) => {
    const definition = definitions.find((def) => lodash_1.concat(def.name, def.version).join(' ') === whitelisted);
    if (!definition)
        throw new Error(`Function ${whitelisted} could not be found. Check if function and version exists.`);
    return definition;
});
exports.whitelistedFunctions = whitelistedFunctions;
/* @doc generateIndex
  Fetches all functions and re-exports them.
  Returns the result as a Buffer.
*/
const generateIndex = (functionsPath, whitelist) => {
    const definitions = functionDefinitions(functionsPath);
    const functions = whitelist
        ? whitelistedFunctions(definitions, whitelist)
        : definitions;
    const code = [];
    code.push(...importFunctions(functions, functionsPath));
    code.push('');
    code.push(...exportFunctions(functions));
    code.push('');
    return code.join('\n');
};
exports.generateIndex = generateIndex;
/* @doc zipFunctionDefinitions
  Takes functionsPath as path to a directory with function definitions.
  Scans each directory for a function.json file, and if present adds it
  to the zip file. Generates an index.js and adds it to the zip file.
  Returns path to the zip file.
*/
const zipFunctionDefinitions = (functionsPath, includes) => {
    const zip = new adm_zip_1.default();
    const tmpDir = '.tmp';
    const zipFilePath = path_1.default.join(tmpDir, 'app.zip');
    const cwd = path_1.default.dirname(functionsPath);
    fs_extra_1.default.ensureDirSync(tmpDir);
    zip.addLocalFile(path_1.default.join(path_1.default.dirname(functionsPath), 'package.json'));
    zip.addFile('index.js', Buffer.from(generateIndex(functionsPath)));
    zip.addLocalFolder(functionsPath, functionsPath.replace(cwd, ''));
    (includes || []).forEach((include) => {
        zip.addLocalFolder(path_1.default.join(cwd, include), include);
    });
    zip.writeZip(zipFilePath);
    return zipFilePath;
};
exports.zipFunctionDefinitions = zipFunctionDefinitions;
//# sourceMappingURL=functionDefinitions.js.map